════════════════════════════════════════════════════════════════════════════════
                    FRONTEND INTERVIEW QUESTIONS
════════════════════════════════════════════════════════════════════════════════


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Q23. Output of the code:- Array Reference Behavior
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

var temp = [1, 2, 3];

((x) => {
  x.push(55);
  console.log(x);
  x = [3, 2, 1];
  x.push(44);
  console.log(x);
})(temp)

console.log(temp);

 EXPLANATION:
In JavaScript, arrays are assigned by reference. In this code, the variable x receives 
a reference to the temp array. When x.push(55) is called, it modifies the original array.
However, when x = [3, 2, 1] is executed, x is reassigned to a new array, and x no longer
references temp. Therefore, the final console.log(temp) shows only the first push.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Q24. 'this' in Regular JS Function vs Arrow Function
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

var variable = "Global Level Variable";

let myObject = {
  variable: "Object Level Variable",
  arrowFunction: () => {
    console.log(this.variable);
  },
  regularFunction() {
    console.log(this.variable);
  }
};

myObject.arrowFunction();      // Output: Global Level Variable
myObject.regularFunction();    // Output: Object Level Variable

 EXPLANATION:
• Arrow Functions: Don't have their own 'this' context. They inherit 'this' from the
  lexical scope (surrounding context). Here, 'this' refers to the global object.

• Regular Functions: Have their own 'this' context, which is bound to the object that
  calls them. Here, 'this' refers to myObject.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Q25. Using filter() to Remove Duplicates from Array
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

let a = [1, 2, 3, 2, 1, 3, 4, 5, 6];
let b = a.filter((ele, i, a) => a.indexOf(ele) === i);

Result: [1, 2, 3, 4, 5, 6]

 EXPLANATION:
The indexOf() method returns the index of the first occurrence of an element.
By comparing i (current index) with indexOf(ele) (first occurrence index), we keep
only elements appearing for the first time, effectively removing duplicates.


━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  Q26. Explain call(), apply(), and bind()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

JavaScript's call(), apply(), and bind() methods control the 'this' context of functions
and allow method borrowing between objects.


┌─────────────────────────────────────────────────────────────────────────────┐
│ USING call()                                                                │
└─────────────────────────────────────────────────────────────────────────────┘

const student1 = {
  name: "sammed",
  callName: function() {
    console.log(this.name);
  }
};

student1.callName();  // Output: "sammed"

const student2 = {
  name: "shrey"
};

student1.callName.call(student2);  // Output: "shrey"

✓ The call() method invokes the function immediately with 'this' set to student2.


┌─────────────────────────────────────────────────────────────────────────────┐
│ USING apply()                                                               │
└─────────────────────────────────────────────────────────────────────────────┘

const student1 = {
  name: "sammed",
  greet: function(message, time) {
    console.log(`${message}, ${this.name}! It's ${time}`);
  }
};

const student2 = {
  name: "shrey"
};

student1.greet.apply(student2, ["Hello", "morning"]);
// Output: "Hello, shrey! It's morning"

✓ apply() is like call() but accepts arguments as an array.
✓ Useful when you have arguments in an array format.


┌─────────────────────────────────────────────────────────────────────────────┐
│ USING bind()                                                                │
└─────────────────────────────────────────────────────────────────────────────┘

const student1 = {
  name: "sammed",
  greet: function(message, time) {
    console.log(`${message}, ${this.name}! It's ${time}`);
  }
};

const student2 = {
  name: "shrey"
};

// Partial binding - first argument pre-filled
const boundGreet = student1.greet.bind(student2, "Hi");
boundGreet("evening");  // Output: "Hi, shrey! It's evening"

// Fully bound function
const fullyBound = student1.greet.bind(student2, "Hello", "night");
fullyBound();  // Output: "Hello, shrey! It's night"

✓ bind() creates a new function without executing it immediately.
✓ Returns a function that can be called later.
✓ Allows partial application (pre-filling some arguments).


┌─────────────────────────────────────────────────────────────────────────────┐
│ KEY DIFFERENCES TABLE                                                       │
└─────────────────────────────────────────────────────────────────────────────┘

Method    │ Executes Immediately │ Arguments Format │ Returns
──────────┼──────────────────────┼──────────────────┼──────────────────────
call()    │ Yes                  │ Individual args  │ Function result
apply()   │ Yes                  │ Array            │ Function result
bind()    │ No (returns func)    │ Individual args  │ New bound function


════════════════════════════════════════════════════════════════════════════════
                    Notes: These methods enable powerful function borrowing
                    and flexible 'this' binding - essential for advanced
                    JavaScript patterns and object-oriented programming.
════════════════════════════════════════════════════════════════════════════════
